
// math
max = fn(x, y) => if x < y then y else x,

// WAVES
pi = 3.14159265,
// Computes a sine wave at the given frequency in hertz (which must be a float or waveform).
$ = fn(freq) => sin(2*pi * freq, 0),
sawtooth = fn(freq) => (res($freq, freq * time) - 0.5) * 2,
square = fn(freq) => alt($freq, 1, -1),
triangle = fn(freq) => let
    t = $freq,
    slope = 4 * freq,
    a = time * slope - 1,
    b = time * -slope + 3
  in alt(t, res(t, a), res(t, b)),
// Computes a pulse wave with the given width. width should be a number (or waveform) between
// 0.0 and 1.0, where 0.0 is a square wave (i.e., 50% duty cycle). If width isn't constant,
// then this is a PWM oscillator.
pulse = fn(width, freq) =>
  let
    // Use a triangle wave (which is lowered by `width`) as the driver for the pulse.
    tri = triangle(freq)
  in
    alt(tri - width, 1, -1),


// HELPERS
amp = fn(level) => fn(w) => w * level,
// slope is in terms of level-change per second
linear = fn(initial, slope) => initial + (time * slope),
// Convert from MIDI note numbers to frequency
@ = fn(m) => pow(2, (m - 69) / 12) * 440,


// ENVELOPES
// Create waveforms for the four parts of the envelope.
Aw = fn(dur) => linear(0.0, 1.0 / dur) | fin(time - dur) | seq(time - dur),
Dw = fn(dur, level) => linear(1.0, (level - 1.0) / dur) | fin(time - dur) | seq(time - dur),
Sw = fn(dur, level) => level | fin(time - dur) | seq(time - dur),
Rw = fn(dur, level) => linear(level, -level / dur) | fin(time - dur) | seq(time - dur),
// Combine them to create a new filter.
ADSR = fn(attack_dur, decay_dur, sustain_level, sustain_dur, release_dur) =>
  fn(w) => (w | seq(0)) * <[Aw(attack_dur),
                            Dw(decay_dur, sustain_level),
                            Sw(sustain_dur, sustain_level),
                            Rw(release_dur, sustain_level)]>,

// Also, we can create component filters... though note that the first three
// don't change the length, so they need to be combined with R (or fin).
A = fn(dur) => fn(w) => w * (Aw(dur) + 1),
D = fn(dur, level) => fn(w) => w * (Dw(dur, level) + 1),
S = fn(dur, level) => fn(w) => w * (Sw(dur, level) + 1),
R = fn(dur, level) => fn(w) => w * Rw(dur, level),

over = fn(freq) => fn (x) => $(freq*x) * (1/x),
hrm = fn(freq) => {map(over(freq), [1, 3, 5, 7, 9, 11])},

add_semitones = fn(freq, n) => freq * pow(2, n/12),
add_cents = fn(freq, n) => freq * pow(2, n/1200),

just_third = fn(freq) => {[hrm(freq), hrm(freq * 5/4)]},
equal_third = fn(freq) => {[hrm(freq), hrm(step(freq, 4))]},


// FILTERS

// Returns a moving average filter with the given order (i.e., with length n+1)
moving_average = fn(n) =>
  filter(fixed(unfold(fn(x) => 1/(n+1), 1/(n+1), n+1)), fixed([])),

// RBJ Cookbook
lpf = fn(Q, fc) =>
  let
    w0 = 2*pi*fc/sampling_frequency,
    alpha = sin(w0)/(2*Q),
    b0 = (1 - cos(w0))/2,
    b1 =  1 - cos(w0),
    b2 = (1 - cos(w0))/2,
    a0 =  1 + alpha,
    a1 = -2*cos(w0),
    a2 =  1 - alpha,
    // Take the first element of w. If w is not a waveform then this will promote it to a constant
    // one before multiplying it, yielding the same result as `fixed([w])`.
    fst = fn(w) => w * fixed([1.0])
  in
    filter(append(fst(b0/a0), fst(b1/a0), fst(b2/a0)), append(fst(a1/a0), fst(a2/a0))),


// INSTRUMENTS

// From Welsh's Synthesizer Cookbook
harmonica = fn(dur, freq) =>
  let
    osc1 = pulse(0.93 + $(1.6) * 0.05, freq),
    osc2 = res(osc1, pulse(0.7, add_cents(add_semitones(freq, 8), 7))),
    osc = osc1 * 0.375 + osc2 * 0.5,
    a = 0.13,
    d = 0.33,
    r = 0.33,
    s = max(dur - (a + d + r), 0)
  in
    osc
    | lpf(0.5, 1900)
    | ADSR(a, d, 0.5, s, r)
    | fin(time - dur) // redundant with the ADSR
    | seq(time - dur),


// Time and Rests
duration_from_beats = fn(beats) => beats * (60 / tempo),

// 4-4 time! (Move to 4-4 file...)
beats_per_measure = 4,
// Note lengths in seconds
W = duration_from_beats(beats_per_measure),
H = W / 2,
Q = W / 4,
E = W / 8,

// Notes as waveforms: use with *
Ww = 1 | fin(time - W) | seq(time - W),
Hw = 1 | fin(time - H) | seq(time - H),
Qw = 1 | fin(time - Q) | seq(time - Q),
Ew = 1 | fin(time - E) | seq(time - E),

// Rests as waveforms: use with <> or +
Wrw = 0 | fin(0) | seq(time - W),
Hrw = 0 | fin(0) | seq(time - H),
Qrw = 0 | fin(0) | seq(time - Q),
Erw = 0 | fin(0) | seq(time - E),

// Some explorations with chords below

// These take the root as a MIDI note number
major_triad = fn(root) => fn(fw) => [fw(@root), fw(@(root + 4)), fw(@(root + 7))],
// major_triad = fn(root, dur, inst) => [inst(dur, @root), inst(dur, @(root + 4)), inst(dur, @(root + 7))],
minor_triad = fn(root) => fn(fw) => [fw(@root), fw(@(root + 3)), fw(@(root + 7))],
// These get a little distorted... may need to scale a bit
I = fn(key) => fn(inst) => fn(dur) => {major_triad(key)(fn(freq) => inst(dur, freq))} | seq(time - dur),
// I = fn(key) => fn(inst) => fn(dur) => {major_triad(key, dur, inst)} | seq(time - dur),
II = fn(key) => fn(inst) => fn(dur) => {major_triad(key + 2)(fn(freq) => inst(dur, freq))} | seq(time - dur),
III = fn(key) => fn(inst) => fn(dur) => {major_triad(key + 4)(fn(freq) => inst(dur, freq))} | seq(time - dur),
i = fn(key) => fn(inst) => fn(dur) => {minor_triad(key)(fn(freq) => inst(dur, freq))} | seq(time - dur),

// In the key of C
I = I(60),
II = II(60),
III = III(60),
i = i(60),

// Played on a harmonica
I = I(harmonica),
II = II(harmonica),
III = III(harmonica),
i = i(harmonica),

// Just notes on harmonica
Hh = fn(freq) => harmonica(H, freq) | seq(time - H),

// <[I H, III H, i H]>
// <[Hh(@67), Hh(@69)]>

// Plays the given waveform w on the beats in bs, starting at 1. For example:
// on_beats(bass, [1, 2, 3, 4])
on_beats = fn(w, bs) => let
  f = fn((offset, prev, ws), play_at_beat) =>
      if offset == play_at_beat
      then (play_at_beat, w, append(ws, [prev | seq(0)]))
      else (play_at_beat, w, append(ws, [prev | seq(time - (duration_from_beats(play_at_beat - offset)))])),
  (offset, prev, ws) = reduce(f, (1, 0 | fin(0), []), bs),
  in <append(ws, [prev])>,
