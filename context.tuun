$ = fn(freq) => sin(freq ~. time),
fs = fn(dur) => fn(w) => w | fin(dur) | seq(dur),

amp = fn(level) => fn(w) => w ~. level,

sawtooth = fn(freq) => (res($freq, time ~. freq) ~+ -0.5) ~. 2,
square = fn(freq) => alt($freq, -1, 1),
triangle = fn(freq) => let
    t = $freq,
    slope = 4*freq,
    a = time ~. slope ~+ -1,
    b = time ~. -slope ~+ 3
  in alt(t, res(t, a), res(t, b)),

// slope is in terms of level-change per beat
linear = fn(initial, slope) => initial ~+ (time ~. (tempo/60 * slope)),

// Create waveforms for the four parts of the envelope.
Aw = fn(dur) => linear(0.0, 1.0 / dur) | fin(dur) | seq(dur),
Dw = fn(dur, level) => linear(1.0, (level - 1.0) / dur) | fin(dur) | seq(dur),
Sw = fn(dur, level) => level | fin(dur) | seq(dur),
Rw = fn(dur, level) => linear(level, -level / dur) | fin(dur) | seq(dur),
// Combine them to create a new filter.
ADSR = fn(attack_dur, decay_dur, sustain_level, sustain_dur, release_dur) =>
  fn(w) => (w | seq(0)) ~. <[Aw(attack_dur),
                             Dw(decay_dur, sustain_level),
                             Sw(sustain_dur, sustain_level),
                             Rw(release_dur, sustain_level)]>,

// Also, we can create component filters... though note that the first three
// don't change the length, so they need to be combined with R (or fin).
A = fn(dur) => fn(w) => w ~. (Aw(dur) ~+ 1),
D = fn(dur, level) => fn(w) => w ~. (Dw(dur, level) ~+ 1),
S = fn(dur, level) => fn(w) => w ~. (Sw(dur, level) ~+ 1),
R = fn(dur, level) => fn(w) => w ~. Rw(dur, level),

over = fn(x, freq) => $(freq*x) ~. (1/x),
hrm = fn(freq) => {map(fn(x) => over(x, freq), [1, 3, 5, 7, 9, 11])},
mar = fn(freq) => {[$freq, over(2.76, freq), over(5.40, freq), over(8.93, freq)]},

step = fn(freq,n) => freq * pow(2, n/12),
just_third = fn(freq) => {[hrm(freq), hrm(freq * 5/4)]},
equal_third = fn(freq) => {[hrm(freq), hrm(step(freq, 4))]},

// Instruments
harmonica = fn(dur, freq) =>
  let a = 0.13,
      d = .33,
      r = .33,
      s = dur - (a + d + r) in
  hrm(freq) | ADSR(a, d, .5, s, r) | seq(dur),

// Convert from MIDI note numbers to frequency
@ = fn(m) => pow(2, (m - 69) / 12) * 440,

beats_per_measure = 4, // beats
Q = beats_per_measure / 4,
H = beats_per_measure / 2,
W = beats_per_measure,

major_triad = fn(root) => fn(fw) => [fw(@root), fw(@(root + 4)), fw(@(root + 7))],
// major_triad = fn(root, dur, inst) => [inst(dur, @root), inst(dur, @(root + 4)), inst(dur, @(root + 7))],
minor_triad = fn(root) => fn(fw) => [fw(@root), fw(@(root + 3)), fw(@(root + 7))],

// These get a little distorted... may need to scale a bit
I = fn(key) => fn(inst) => fn(dur) => {major_triad(key)(fn(freq) => inst(dur, freq))} | seq(dur),
// I = fn(key) => fn(inst) => fn(dur) => {major_triad(key, dur, inst)} | seq(dur),
II = fn(key) => fn(inst) => fn(dur) => {major_triad(key + 2)(fn(freq) => inst(dur, freq))} | seq(dur),
III = fn(key) => fn(inst) => fn(dur) => {major_triad(key + 4)(fn(freq) => inst(dur, freq))} | seq(dur),
i = fn(key) => fn(inst) => fn(dur) => {minor_triad(key)(fn(freq) => inst(dur, freq))} | seq(dur),

// In the key of C
I = I(60),
II = II(60),
III = III(60),
i = i(60),

// Played on a harmonica
I = I(harmonica),
II = II(harmonica),
III = III(harmonica),
i = i(harmonica),

// Just notes on harmonica
Hh = fn(freq) => harmonica(H, freq) | seq(H)

// <[I H, III H, i H]>
// <[Hh(@67), Hh(@69)]>
